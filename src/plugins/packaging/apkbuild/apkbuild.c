/*
 * apkbuild.c - for Ad√©lie and Alpine Linux
 *
 * Copyright (C) 2015 Intel Corporation
 * Copyright (C) 2019 Max Rees
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#define _GNU_SOURCE
#include <glib.h>
#include <libgen.h>
#include <limits.h>
#include <stdlib.h>
#include <sys/stat.h>

#include "apkbuild.h"
#include "plugin.h"
#include "util.h"

static gint _gcmpstr(gconstpointer a, gconstpointer b)
{
        return g_strcmp0((const gchar *)a, (const gchar *)b);
}

struct source_package_t *apkbuild_inspect_spec(const char *filename)
{
        autofree(GFile) *fi = g_file_new_for_path(filename);
        autofree(GError) *error = NULL;
        if (!fi) {
                return NULL;
        }
        autofree(GFileInputStream) *fis = g_file_read(fi, NULL, &error);
        if (error) {
                g_printerr("Unable to read: %s\n", error->message);
                return NULL;
        }
        struct source_package_t *t = calloc(1, sizeof(struct source_package_t));
        if (!t) {
                return NULL;
        }
        t->extra = NULL;

        autofree(GDataInputStream) *dis = g_data_input_stream_new(G_INPUT_STREAM(fis));
        char *read = NULL;
        char *fpath = NULL;
        autofree(gchar) *name = NULL;
        autofree(gchar) *version = NULL;
        autofree(gchar) *release = NULL;

        while ((read = g_data_input_stream_read_line(dis, NULL, NULL, NULL)) != NULL) {
                autofree(gstrv) *strv = NULL;
                const gchar *key = NULL;
                autofree(gchar) *value = NULL;

                read = g_strstrip(read);

                if (strchr(read, '=')) {
                        strv = g_strsplit(read, "=", 2);
                        if (g_strv_length(strv) < 2) {
                                goto clean;
                        }
                        key = strv[0];
                        value = g_strstrip(g_strdup(strv[1]));
                } else if (g_str_has_prefix(read, "# secfixes: ")) {
                        key = "pkgname";
                        value = g_strstrip(g_strdup(read + 12));
                        value = g_strstrip(value);
                        if (!value) {
                                goto clean;
                        }
                } else if (g_str_has_prefix(read, "#     - CVE-")) {
                        value = g_strstrip(g_strdup(read + 8));
                        if (!value) {
                                goto clean;
                        }
                        t->extra = g_list_prepend(t->extra, g_strdup(value));
                        goto clean;
                } else {
                        goto clean;
                }

                if (g_str_equal(key, "pkgname")) {
                        name = g_strdup(value);
                } else if (g_str_equal(key, "pkgver")) {
                        version = g_strdup(value);
                } else if (g_str_equal(key, "pkgrel")) {
                        release = g_strdup(value);
                }

        clean:
                g_free(read);
        }

        if (!name || !version || !release) {
                return NULL;
        }

        fpath = cve_get_file_parent(filename);
        if (!fpath) {
                return NULL;
        }

        t->name = g_strdup(name);
        t->version = g_strdup(version);
        t->release = atoi(release);
        t->path = fpath;
        t->type = PACKAGE_TYPE_APKBUILD;
        return t;
}

bool apkbuild_is_patched(struct source_package_t *pkg, char *id)
{
        if (g_list_find_custom(pkg->extra, id, _gcmpstr)) {
                return true;
        }

        autofree(gchar) *pname = g_strdup_printf("%s/%s.patch", pkg->path, id);
        if (g_file_test(pname, G_FILE_TEST_EXISTS)) {
                return true;
        }

        return false;
}

bool apkbuild_is_package(const char *filename)
{
        return g_str_has_suffix((const gchar *)filename, "APKBUILD");
}

void apkbuild_free_package(struct source_package_t *pkg)
{
        g_list_free_full(pkg->extra, g_free);
}

void apkbuild_locate_sources(const char *directory, bool recurse, cve_add_callback cb)
{
        find_sources(directory, &apkbuild_is_package, recurse, cb);
}

_module_export_ bool cve_plugin_module_init(CvePlugin *self)
{
        self->flags = PLUGIN_TYPE_PACKAGE;
        self->name = "apkbuild";
        self->is_patched = apkbuild_is_patched;
        self->is_package = apkbuild_is_package;
        self->scan_package = apkbuild_inspect_spec;
        self->scan_archive = NULL;
        self->is_ignored = NULL;
        self->free_package = apkbuild_free_package;
        return true;
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 expandtab:
 * :indentSize=8:tabSize=8:noTabs=true:
 */
