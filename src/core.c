/*
 * core.c - cve-check-tool
 *
 * Copyright (C) 2015 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#define _GNU_SOURCE
#include "config.h"

#include <curl/curl.h>
#include <fcntl.h>
#include <gio/gio.h>
#include <glib.h>
#include <inttypes.h>
#include <jansson.h>
#include <malloc.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#include "core.h"
#include "cve-check-tool.h"

#include "cve-string.h"
#include "util.h"

#include <sqlite3.h>

const char *nvd_file = "nvd.db";
const char *nvd_dir = "NVDS";
bool use_frac_compare = false;

struct CveDB {
        const char *cur_id;

        /* SQL usage */
        sqlite3 *db;
        sqlite3_stmt *insert;
        sqlite3_stmt *insert_product;
        sqlite3_stmt *search_product;
        sqlite3_stmt *get_cve;
};

#define TABLE_NAME "NVD"

static bool ensure_table(CveDB *self)
{
        if (!self || !self->db) {
                return false;
        }
        int rc = 0;
        char *err = NULL;
        const char *query;

        /* If we crash we've already broken our DB anyway. */
        query = "PRAGMA synchronous = OFF;PRAGMA journal_mode = MEMORY;";
        rc = sqlite3_exec(self->db, query, NULL, NULL, &err);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "ensure_table(): %s\n", err);
                sqlite3_free(err);
                return false;
        }

        query = "CREATE TABLE IF NOT EXISTS " TABLE_NAME
                " "
                "(ID TEXT UNIQUE, SUMMARY TEXT, SCORE DOUBLE, MODIFIED INTEGER, VECTOR TEXT);";
        rc = sqlite3_exec(self->db, query, NULL, NULL, &err);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "ensure_table(): %s\n", err);
                sqlite3_free(err);
                return false;
        }

        query =
            "CREATE TABLE IF NOT EXISTS PRODUCTS (HASH INTEGER UNIQUE, ID TEXT, VENDOR TEXT, PRODUCT TEXT, VERSION "
            "TEXT);";
        rc = sqlite3_exec(self->db, query, NULL, NULL, &err);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "ensure_table(): %s\n", err);
                sqlite3_free(err);
                return false;
        }
        if (err) {
                sqlite3_free(err);
        }

        return true;
}

struct cve_entry_t *cve_db_get_cve(CveDB *self, char *id)
{
        struct cve_entry_t *t = NULL;
        int rc = 0;

        if (!self || !self->db || !id) {
                return NULL;
        }

        sqlite3_reset(self->get_cve);

        if (sqlite3_bind_text(self->get_cve, 1, id, -1, SQLITE_STATIC) != SQLITE_OK) {
                fprintf(stderr, "cve_db_get_cve(): %s\n", sqlite3_errmsg(self->db));
                return NULL;
        }

        rc = sqlite3_step(self->get_cve);
        if (rc != SQLITE_ROW) {
                fprintf(stderr, "cve_db_get_cve(): %s\n", sqlite3_errmsg(self->db));
                return NULL;
        }

        // ID TEXT UNIQUE, SUMMARY TEXT, SCORE TEXT, MODIFIED INTEGER, VECTOR TEXT
        t = calloc(1, sizeof(struct cve_entry_t));
        if (!t) {
                fprintf(stderr, "cve_db_get_cve(): Memory failure\n");
                return NULL;
        }

        t->id = g_strdup((const char *)sqlite3_column_text(self->get_cve, 0));
        t->summary = g_strdup((const char *)sqlite3_column_text(self->get_cve, 1));
        t->score = g_strdup_printf("%f", sqlite3_column_double(self->get_cve, 2));
        t->modified = sqlite3_column_int64(self->get_cve, 3);
        t->vector = g_strdup((const char *)sqlite3_column_text(self->get_cve, 4));

        return t;
}

GList *cve_db_get_issues_frac_compare(CveDB *self, char *product, char *version)
{
        int rc = 0;
        GList *list = NULL;
        int ret = 0;

        if (!self || !self->db) {
                return NULL;
        }

        sqlite3_reset(self->search_product);

        if (sqlite3_bind_text(self->search_product, 1, product, -1, SQLITE_STATIC) != SQLITE_OK) {
                fprintf(stderr, "cve_db_get_issues_frac_compare(): %s\n", sqlite3_errmsg(self->db));
                return NULL;
        }

        while ((rc = sqlite3_step(self->search_product)) == SQLITE_ROW) {
                if ((const char *)sqlite3_column_text(self->search_product, 1) == NULL) /*skip over (null) product*/
                        continue;
                if ((const char *)sqlite3_column_text(self->search_product, 2) == NULL) /*skip over (null) version*/
                        continue;

                ret = strverscmp(version, (const char *)sqlite3_column_text(self->search_product, 2));
                if (ret <= 0) { /* our version <= NVD version */
                        list =
                            g_list_append(list, g_strdup((const char *)sqlite3_column_text(self->search_product, 0)));
                }
        }

        if (rc != SQLITE_DONE) {
                if (list) {
                        g_list_free_full(list, g_free);
                        return NULL;
                }
        }

        return list;
}

GList *cve_db_get_issues(CveDB *self, char *product, char *version)
{
        int rc = 0;
        GList *list = NULL;

        if (!self || !self->db) {
                return NULL;
        }

        sqlite3_reset(self->search_product);

        /* Product */
        if (sqlite3_bind_text(self->search_product, 1, product, -1, SQLITE_STATIC) != SQLITE_OK) {
                fprintf(stderr, "cve_db_get_issues(): %s\n", sqlite3_errmsg(self->db));
                goto bail;
        }
        /* Version */
        if (sqlite3_bind_text(self->search_product, 2, version, -1, SQLITE_STATIC) != SQLITE_OK) {
                fprintf(stderr, "cve_db_get_issues(): %s\n", sqlite3_errmsg(self->db));
                goto bail;
        }

        while ((rc = sqlite3_step(self->search_product) == SQLITE_ROW)) {
                list = g_list_append(list, g_strdup((const gchar *)sqlite3_column_text(self->search_product, 0)));
        }
        if (rc != SQLITE_OK) {
                fprintf(stderr, "cve_db_get_issues(): %s\n", sqlite3_errmsg(self->db));
                if (list) {
                        g_list_free_full(list, g_free);
                        return NULL;
                }
        }
bail:
        return list;
}


enum SqliteOrder {
        SqliteOrderID = 1,
        SqliteOrderSummary,
        SqliteOrderScore,
        SqliteOrderModified,
        SqliteOrderVector
};

enum SqliteOrderVuln {
        SqliteOrderVulnHash = 1,
        SqliteOrderVulnID,
        SqliteOrderVulnVendor,
        SqliteOrderVulnProduct,
        SqliteOrderVulnVersion
};

static void process_description(CveDB *self, json_t* descr) {
        json_t *data = json_object_get(descr, "description_data");

        if (!json_is_array(data)) {
                fprintf(stderr, "process_description(): field 'description_data' cannot be found or is not an array\n");
        }

        size_t size = json_array_size(data);

        /* Min items: 0 */
        for (size_t i = 0; i < size; ++i) {
                json_t *item = json_array_get(data, i);
                json_t *lang = json_object_get(item, "lang");
                const char *lang_str = json_string_value(lang);

                if (lang_str == NULL) {
                        fprintf(stderr, "process_description(): field 'lang' cannot be found or is not a string\n");
                }

                if (lang_str && !strcmp(lang_str, "en")) {
                        json_t *value = json_object_get(item, "value");

                        if (json_is_string(value)) {
                                if (sqlite3_bind_text(self->insert, SqliteOrderSummary, json_string_value(value), -1,
                                    SQLITE_STATIC) != SQLITE_OK)
                                {
                                        fprintf(stderr, "process_description(): %s\n", sqlite3_errmsg(self->db));
                                }
                        }
                        else {
                                fprintf(stderr, "process_description(): field 'value' cannot be found or is not a string\n");
                        }
                        break;
                }
        }
}

static void process_cve_metadata(CveDB *self, json_t *r) {
        json_t *data    = json_object_get(r, "ID");
        const char *str = json_string_value(data);

        if (str == NULL) {
                fprintf(stderr, "process_cve_metadata(): field 'ID' cannot be found or is not a string\n");
        }

        if (sqlite3_bind_text(self->insert, SqliteOrderID, str, -1, SQLITE_STATIC) != SQLITE_OK) {
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
        }

        /* Set current cve id for later use */
        self->cur_id = str;
}

static void sqlite_bind_vuln(CveDB *self, struct vulnerability_t* vuln) {
        autofree(gchar) *hash = NULL;

        if (self->cur_id && vuln->vendor && vuln->product && vuln->version) {
                hash = g_strdup_printf("%s:%s:%s:%s", self->cur_id, vuln->vendor, vuln->product, vuln->version);
                vuln->hash = g_str_hash(hash);
        }
        else {
                vuln->hash = -1;
                fprintf(stderr, "sqlite_bind_vuln(): skip hash calculation: some required fields could't found\n");
        }

        sqlite3_reset(self->insert_product);

        if (sqlite3_bind_int(self->insert_product, SqliteOrderVulnHash, vuln->hash) != SQLITE_OK) {
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
        }
        if (sqlite3_bind_text(self->insert_product, SqliteOrderVulnID,
            self->cur_id, -1, SQLITE_STATIC) != SQLITE_OK)
        {
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
        }
        if (sqlite3_bind_text(self->insert_product, SqliteOrderVulnVendor,
            vuln->vendor, -1, SQLITE_STATIC) != SQLITE_OK)
        {
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
        }
        if (sqlite3_bind_text(self->insert_product, SqliteOrderVulnProduct,
            vuln->product, -1, SQLITE_STATIC) != SQLITE_OK)
        {
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
        }
        if (sqlite3_bind_text(self->insert_product, SqliteOrderVulnVersion,
            vuln->version, -1, SQLITE_STATIC) != SQLITE_OK)
        {
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
        }

        if (sqlite3_step(self->insert_product) != SQLITE_DONE) {
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
        }
}

static void process_versions(CveDB *self, json_t *r, struct vulnerability_t* vuln) {
        size_t size = json_array_size(r);

        /* Min items: 1 */
        if (size < 1) {
                fprintf(stderr, "process_versions(): array 'version_data' cannot be empty\n");
                vuln->version = NULL;
                sqlite_bind_vuln(self, vuln);
                return;
        }

        for (size_t i = 0; i < size; ++i) {
                json_t *version_node  = json_array_get(r, i);
                json_t *version_value = json_object_get(version_node, "version_value");

                vuln->version = json_string_value(version_value);

                if (vuln->version == NULL) {
                        fprintf(stderr, "process_versions(): field 'version_value' cannot be found or is not a string\n");
                }

                sqlite_bind_vuln(self, vuln);
        }
}

static void process_affects(CveDB *self, json_t *r) {
        json_t *vendor = json_object_get(r, "vendor");

        if (!json_is_object(vendor)) {
                fprintf(stderr, "process_affects(): field 'vendor' cannot be found or is not an object\n");
                return;
        }

        json_t *vendor_data = json_object_get(vendor, "vendor_data");

        if (!json_is_array(vendor_data)) {
                fprintf(stderr, "process_affects(): field 'vendor_data' cannot be found or is not an array\n");
                return;
        }

        size_t size = json_array_size(vendor_data);

        struct vulnerability_t vuln;

        /* Min items: 0 */
        for (size_t v = 0; v < size; ++v) {
                json_t *node = json_array_get(vendor_data, v);
                json_t *vendor_name = json_object_get(node, "vendor_name");

                vuln.vendor = json_string_value(vendor_name);

                if (vuln.vendor == NULL) {
                        fprintf(stderr, "process_affects(): field 'vendor_name' cannot be found or is not a string\n");
                }

                json_t *product = json_object_get(node, "product");

                if (!json_is_object(product)) {
                        fprintf(stderr, "process_affects(): field 'product' cannot be found or is not an object\n");
                        continue;
                }

                json_t *product_data = json_object_get(product, "product_data");
                size_t products_size = json_array_size(product_data);

                /* Min items: 1 */
                if (products_size < 1) {
                        fprintf(stderr, "process_affects(): array 'product_data' cannot be found or is empty\n");
                        continue;
                }

                for (size_t p = 0; p < products_size; ++p) {
                        json_t *product_node = json_array_get(product_data, p);
                        json_t *product_name = json_object_get(product_node, "product_name");

                        vuln.product = json_string_value(product_name);

                        if (vuln.product == NULL) {
                                fprintf(stderr, "process_affects(): field 'product_name' cannot be found or is not a string\n");
                        }

                        json_t *version = json_object_get(product_node, "version");

                        if (!json_is_object(version)) {
                                fprintf(stderr, "process_affects(): field 'version' cannot be found or is not an object\n");
                                continue;
                        }

                        json_t *version_data = json_object_get(version, "version_data");

                        if (!json_is_array(version_data)) {
                                fprintf(stderr, "process_affects(): field 'version_data' cannot be found or is not an array\n");
                                continue;
                        }

                        process_versions(self, version_data, &vuln);
                }
        }
}

static void process_cve(CveDB *self, json_t *r) {
        json_t *cve_data_meta = json_object_get(r, "CVE_data_meta");
        json_t *description   = json_object_get(r, "description");
        json_t *affects       = json_object_get(r, "affects");

        if (json_is_object(cve_data_meta)) {
                process_cve_metadata(self, cve_data_meta);
        }
        else {
                fprintf(stderr, "process_cve(): field 'CVE_data_meta' cannot be found or is not an object\n");
        }

        if (json_is_object(description)) {
                process_description(self, description);
        }
        else {
                fprintf(stderr, "process_cve(): field 'description' cannot be found or is not an object\n");
        }

        if (json_is_object(affects)) {
                process_affects(self, affects);
        }
        else {
                fprintf(stderr, "process_cve(): field 'affects' cannot be found or is not an object\n");
        }
}

static void process_impact(CveDB *self, json_t *r) {
        // baseMetrics and cvss are optional
        json_t *metric = json_object_get(r, "baseMetricV2");
        json_t *cvss   = NULL;
        json_t *vector = NULL;

        if (metric == NULL) {
                if ((metric = json_object_get(r, "baseMetricV3")) == NULL) {
                        return;
                }

                cvss   = json_object_get(metric, "cvssV3");
                vector = json_object_get(cvss, "attackVector");
        }
        else {
                cvss = json_object_get(metric, "cvssV2");
                vector = json_object_get(cvss, "accessVector");
        }

        json_t* score = json_object_get(cvss, "baseScore");

        if (score && json_is_real(score)) {
                if ((sqlite3_bind_double(self->insert, SqliteOrderScore, json_real_value(score)) != SQLITE_OK)) {
                        fprintf(stderr, "process_impact(): %s\n", sqlite3_errmsg(self->db));
                }
        } else {
                fprintf(stderr, "process_impact(): field 'baseScore' cannot be found or is not a real number\n");
        }

        const char *vector_str = json_string_value(vector);

        if (vector_str == NULL) {
                fprintf(stderr, "process_impact(): field 'accessVector'/'attackVector' cannot be found or is not a string\n");
        }

        if (sqlite3_bind_text(self->insert, SqliteOrderVector, json_string_value(vector), -1, SQLITE_STATIC) != SQLITE_OK) {
                fprintf(stderr, "process_impact(): %s\n", sqlite3_errmsg(self->db));
        }
}

static void process_last_modified(CveDB *self, json_t *r) {
        int64_t last_mod = -1;

        const char *date = json_string_value(r);

        if (date == NULL) {
                fprintf(stderr, "process_last_modified(): field 'lastModifiedDate' is not a string\n");
        }
        else if ((last_mod = parse_date(date)) == -1) {
                fprintf(stderr, "process_last_modified(): invalid date at key 'lastModifiedDate'\n");
        }

        if (sqlite3_bind_int64(self->insert, SqliteOrderModified, last_mod) != SQLITE_OK) {
                fprintf(stderr, "process_last_modified(): %s\n", sqlite3_errmsg(self->db));
        }
}

static bool process_json(CveDB *self, json_t *r) {
        json_t *cve_items = json_object_get(r, "CVE_Items");

        size_t size = json_array_size(cve_items);

        if (size < 1) {
                fprintf(stderr, "process_json(): array 'CVE_Items' cannot be found or is empty\n");
                return false;
        }

        for (size_t i = 0; i < size; ++i) {
                sqlite3_reset(self->insert);

                json_t *node = json_array_get(cve_items, i);

                json_t *cve    = json_object_get(node, "cve");
                json_t *date   = json_object_get(node, "lastModifiedDate");
                json_t *impact = json_object_get(node, "impact");

                if (json_is_object(cve)) {
                        process_cve(self, cve);
                } else {
                        fprintf(stderr, "process_json(): field 'cve' cannot be found or is not an object\n");
                }

                /* lastModifiedDate is optional */
                if (date) {
                        process_last_modified(self, date);
                }

                /* impact is optional */
                if (impact) {
                        process_impact(self, impact);
                }

                if (sqlite3_step(self->insert) != SQLITE_DONE) {
                        fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
                }
        }

        return true;
}

static json_t *load_json(const char *filename) {
        json_t *root;
        json_error_t error;

        root = json_load_file(filename, 0, &error);

        if (root) {
                return root;
        } else {
                fprintf(stderr, "Json error: %s:%d: %s\n", filename, error.line, error.text);
                return NULL;
        }
}

/**
 * Parse an NVD json database
 *
 * @param fname Path to the nvd db
 * @return a boolean value, true if the operation succeeded
 */
bool cve_db_load(CveDB *self, const char *fname)
{
        bool b = false;
        __attribute__((unused)) int rc;

        if (!self || !fname) {
                return false;
        }

        json_t* r = load_json(fname);

        if (r == NULL) {
                return false;
        }

        b = process_json(self, r);

        json_decref(r);

        /* Remove dangling pointer to const char* string */
        self->cur_id = NULL;

#ifdef HAVE_MALLOC_TRIM
        malloc_trim(0);
#endif

        return b;
}

bool cve_db_finalize(CveDB *self)
{
        int rc;
        const char *query;

        rc = sqlite3_exec(self->db, "END TRANSACTION;", NULL, NULL, NULL);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "cve_db_finalize(): %s\n", sqlite3_errmsg(self->db));
                return false;
        }

        query = "CREATE INDEX IF NOT EXISTS PRODUCT_IDX ON PRODUCTS (PRODUCT, VERSION);";
        rc = sqlite3_exec(self->db, query, NULL, NULL, NULL);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "cve_db_finalize(): %s\n", sqlite3_errmsg(self->db));
                return false;
        }
        return true;
}

bool cve_db_begin(CveDB *self)
{
        int rc;

        rc = sqlite3_exec(self->db, "BEGIN TRANSACTION;", NULL, NULL, NULL);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "cve_db_begin(): %s\n", sqlite3_errmsg(self->db));
                return false;
        }
        return true;
}

CveDB *cve_db_new(const char *path)
{
        CveDB *ret = NULL;
        sqlite3 *r = NULL;
        int rc = 0;
        const char *q;
        sqlite3_stmt *stm = NULL;

        ret = calloc(1, sizeof(struct CveDB));
        if (!ret) {
                fprintf(stdout, "cve_db_new: Out of memory\n");
                return NULL;
        }

        rc = sqlite3_open(path, &r);
        if (rc != SQLITE_OK) {
                if (r) {
                        sqlite3_close(r);
                }
                free(ret);
                return NULL;
        }
        ret->db = r;

        if (!ensure_table(ret)) {
                fprintf(stderr, "cve_db_new(): Table construction failure\n");
                cve_db_free(ret);
                return NULL;
        }

        q = "INSERT OR REPLACE INTO " TABLE_NAME " VALUES (?, ?, ?, ?, ?);";

        rc = sqlite3_prepare_v2(ret->db, q, -1, &stm, NULL);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "cve_db_new(): %s\n", sqlite3_errmsg(ret->db));
                cve_db_free(ret);
                return NULL;
        }
        ret->insert = stm;
        stm = NULL;

        /* Insert product. */
        q = "INSERT OR REPLACE INTO PRODUCTS VALUES (?, ?, ?, ?, ?)";
        rc = sqlite3_prepare_v2(ret->db, q, -1, &stm, NULL);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "cve_db_new(): %s\n", sqlite3_errmsg(ret->db));
                cve_db_free(ret);
                return NULL;
        }
        ret->insert_product = stm;
        stm = NULL;

        /* Search product. */
        if (use_frac_compare) {
                q = "select ID, PRODUCT, VERSION from PRODUCTS where PRODUCT = ?";
        } else {
                q = "SELECT ID FROM PRODUCTS WHERE PRODUCT = ? AND VERSION = ? COLLATE NOCASE";
        }
        rc = sqlite3_prepare_v2(ret->db, q, -1, &stm, NULL);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "cve_db_new(): %s\n", sqlite3_errmsg(ret->db));
                cve_db_free(ret);
                return NULL;
        }
        ret->search_product = stm;
        stm = NULL;

        /* Get CVE. */
        q = "SELECT * FROM NVD WHERE ID = ?";
        rc = sqlite3_prepare_v2(ret->db, q, -1, &stm, NULL);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "cve_db_new(): %s\n", sqlite3_errmsg(ret->db));
                cve_db_free(ret);
                return NULL;
        }
        ret->get_cve = stm;
        stm = NULL;

        return ret;
}

void cve_db_free(CveDB *self)
{
        if (!self) {
                return;
        }
        if (self->insert) {
                sqlite3_finalize(self->insert);
        }
        if (self->insert_product) {
                sqlite3_finalize(self->insert_product);
        }
        if (self->search_product) {
                sqlite3_finalize(self->search_product);
        }
        if (self->get_cve) {
                sqlite3_finalize(self->get_cve);
        }
        if (self->db) {
                sqlite3_close(self->db);
        }
        free(self);
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 expandtab:
 * :indentSize=8:tabSize=8:noTabs=true:
 */
